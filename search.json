[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cours de complÃ©ments dâ€™informatique",
    "section": "",
    "text": "ğŸš§\n\nObjectifs\nVous apporter les connaissances pour :\n\nmener Ã  bien votre projet informatique\ndÃ©velopper votre culture informatique\nvous permettre de comprendre les outils de traitements de la donnÃ©e\n\nDiffÃ©rentes notions vont Ãªtre vues pendant ce cours. Certaines en CM, dâ€™autres en TP. Des ressources complÃ©mentaires vous sont proposÃ©es si vous souhaitez parfaire vos connaissances.\n\n\nOrganisation\n\nCM : 4x1h30\nTP : 4x3h\n\n\n\nCours\n\nCours nÂ°1\nCours nÂ°2\n\n\n\nTP\n\nTP nÂ°1"
  },
  {
    "objectID": "docs/cours/cm2.html#comment-stocker-les-donnÃ©es",
    "href": "docs/cours/cm2.html#comment-stocker-les-donnÃ©es",
    "title": "CM2",
    "section": "1.1 Comment stocker les donnÃ©es",
    "text": "1.1 Comment stocker les donnÃ©es\ndans calc"
  },
  {
    "objectID": "docs/cours/cm2.html#les-bddr",
    "href": "docs/cours/cm2.html#les-bddr",
    "title": "CM2",
    "section": "1.2 les bddr",
    "text": "1.2 les bddr\nBddr"
  },
  {
    "objectID": "docs/cours/cm1.html#comment-stocker-les-donnÃ©es",
    "href": "docs/cours/cm1.html#comment-stocker-les-donnÃ©es",
    "title": "CM1",
    "section": "1.1 Comment stocker les donnÃ©es",
    "text": "1.1 Comment stocker les donnÃ©es\ndans calc"
  },
  {
    "objectID": "docs/cours/cm1.html#les-bddr",
    "href": "docs/cours/cm1.html#les-bddr",
    "title": "CM1",
    "section": "1.2 les bddr",
    "text": "1.2 les bddr\nBddr"
  },
  {
    "objectID": "docs/tp/tp1.html",
    "href": "docs/tp/tp1.html",
    "title": "TP1",
    "section": "",
    "text": "Ce TP mÃªle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais prÃ©fÃ©rez toujours les explications orales.\n\n\n\n\nVous allez crÃ©er les objets mÃ©tier pour un jeu PokÃ©mon.\nUn objet mÃ©tier reprÃ©sente dans votre code quelque chose de concret, qui modÃ¨lise la rÃ©alitÃ©.\n\nObjet mÃ©tier (business object) : reprÃ©sentation informatique dâ€™un objet â€œrÃ©elâ€ que notre programme va manipuler pour rÃ©pondre Ã  un besoin. Dans le cas de notre application cela sera des PokÃ©mons, des attaques ou des objets.\nDans une application de e-commerce par exemple, les articles et comptes sont des objets mÃ©tier. Ils permettent de sÃ©parer les donnÃ©es de lâ€™application et les traitements. Cela conduit Ã  avoir des objets contenant essentiellement des attributs et trÃ¨s peu de mÃ©thodes autre que des getter et setter.\n\nCe TP sera rÃ©alisÃ© avec lâ€™IDE (Integred Development Environment) Visual Studio Code.\n\n\n\nOuvrez Git Bash\nCrÃ©ez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, puis collez lÃ  dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_\n\nClonez le dÃ©pÃ´t\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAller dans /p/Cours2A/UE3_Complements_informatique/TP/TP1/ (ou dans le dossier oÃ¹ se situe le dÃ©pÃ´t que vous venez de cloner)\ncliquer sur ENSAI-2A-complement-info-TP, puis sur le bouton SÃ©lectionner un dossier\nâš ï¸ câ€™est trÃ¨s important de suivre trÃ¨s prÃ©cisÃ©ment ces consignes, sinon vous risquez dâ€™avoir des soucis dâ€™import !\n\n\n\nLisez le fichier README.md et suivez les instructions. Puis lancez le programme main.py pour vous assurer que tout fonctionne correctement.\n\nOuvrez un terminal dans VSCode (CTRL + Ã¹)\n\ncâ€™est le mÃªme terminal Git Bash que vous avez ouvert au dÃ©but\nmais câ€™est plus pratique dâ€™avoir tout au mÃªme endroit\n\nlistez les branches git branch -a\n\nVous avez la possibilitÃ© de consulter la correction en changeant de branche si et seulement si vous Ãªtes bloquÃ© trop longtemps.\nVoici quelques commandes git utiles :\n# Avant de changer de branches, crÃ©ez un point de sauvegarde de votre travail\ngit add .\ngit commit -am \"&lt;message&gt;\"\n\n# changer de branche\ngit checkout &lt;nouvelle_branche&gt;      # dans le terminal, la branche courante est indiquÃ©Ã©e entre ()\ngit checkout -                       # pour retourner Ã  la branche prÃ©cÃ©dente\n\n\n\n\nNotre jeu sâ€™inspirera de PokÃ©mon Unite (aucune connaissance du jeu, ni de PokÃ©mon nâ€™est nÃ©cessaire).\nPour rÃ©sumer en quelques mots, voici les objets que nous allons manipuler :\n\nPokemon : qui ont diverses caractÃ©ristiques et statistiques\n\nhp : health points\nattack, defense, speedâ€¦ : qui serviront dÃ©terminer la force de ses attaques\nun type : Attacker, Defender, All Rounder, Speedster, Supporter\n\nStatistic : pour Ã©viter de surcharger la classe Pokemon, de nombreuses stats sont stockÃ©es dans un objet de la classe Statistic\nAttack : diffÃ©rents types dâ€™attaques dont disposeront les PokÃ©mons (partie 3)\nBattleService : servira Ã  faire sâ€™affronter 2 PokÃ©mons pour dÃ©terminer lâ€™issue du combat (partie 4)\n\n\n\n\n\n\n\nDans un premier temps, nous allons coder uniquement les Pokemons (la classe Statistic est dÃ©jÃ  codÃ©e). En fonction de son type, son coefficient dâ€™attaque dÃ©pendra de diverses statistiques.\n\n\n\n\n\nclassDiagram\n class Pokemon {\n - __type : String\n - __current_stat : Statistique\n + get_pokemon_attack_coef() float\n }\n \n class Statistic {\n - __hp : int\n - __attaque : int\n - __defense : int\n - __spe_atk : int\n - __spe_def : int\n - __vitesse : int\n }\n Pokemon --&gt; Statistic : possÃ¨de\n\n\n\n\n\nAvant dâ€™Ã©crire du code, nous allons rÃ©flÃ©chir Ã  la meilleure conception possible pour rÃ©aliser nos PokÃ©mons. Notre conception essaiera au maximum de respecter la rÃ¨gle suivante : faible couplage, forte cohÃ©sion.\nEn dâ€™autre termes nous allons essayer de faire :\n\ndes classes les plus disjointes possible (faible couplage) pour quâ€™une modification dans une classe ne nous demande pas de modifier les autres\ntout en essayant dâ€™avoir les tÃ¢ches rÃ©alisÃ©es par une seule classe les plus liÃ©es possible (forte cohÃ©sion).\n\n\n\nOuvrez le code, et observez la classe Pokemon. Nous nous interessons Ã  la mÃ©thode get_pokemon_attack_coef() qui va servir Ã  dÃ©terminer la puissance de lâ€™attaque en fonction du type de PokÃ©mon.\n\n\nQuestion 1 : Expliquez pourquoi une implÃ©mentation Ã  base de if/elif/else pour les types est une mauvaise idÃ©e ? Imaginez sâ€™il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.\n\n\n\n\n\n\nAu lieu dâ€™externaliser les comportements de nos PokÃ©mons, nous allons mettre tous leurs comportements spÃ©cifiques dans des classes filles dâ€™une super classe Pokemon. Ceci est rendu possible grÃ¢ce Ã  deux propriÃ©tÃ©s des objets en POO :\n\nhÃ©ritage : il est possible de spÃ©cialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux\npolymorphisme : deux fonctions peuvent avoir le mÃªme nom mais avoir des comportements diffÃ©rents\n\nEn plus, comme chacun de nos PokÃ©mons va forcement Ãªtre dâ€™un type, aucun ne sera simplement de la classe Pokemon, cela nous permet de rendre cette classe abstraite. En dÃ©finissant clairement notre classe abstraite nous allons avoir :\n\nUn plan pour toutes les classes qui en hÃ©ritent. Cela Ã  pour avantages de :\n\nDonner des informations sur la structuration du code\n\nPermettre de gÃ©nÃ©rer automatiquement les mÃ©thodes Ã  dÃ©finir\nLimiter les bug. Si on oublie une mÃ©thode, le code plante au dÃ©marrage, ce qui Ã©vite des comportements non prÃ©vus difficile Ã  dÃ©tecter\n\nUne interface unique pour tous les types de PokÃ©mons. Quelque soit le type du PokÃ©mon, il sera considÃ©rÃ© comme un AbstractPokemon partout dans le code.\n\n\n\n\nQuestion 2 :\n\ntransformez la classe Pokemon en classe abstraite AbstractPokemon\n\nrenommez Ã©galement le fichier en abstract_pokemon.py\n\ntransformez la mÃ©thode get_pokemon_attack_coef() en mÃ©thode abstraite\ncrÃ©ez les classes Attacker, Defender et AllRounder qui hÃ©ritent de AbstractPokemon\ndans ces 3 classes, implÃ©mentez la mÃ©thode get_pokemon_attack_coef()\n\n\n\nPour vous aider, voici le diagramme de classe :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    +get_pokemon_attack_coef() :  float\n  }\n  \n  class BattleService {\n    +resolve_battle() Battle\n  } \n \n  class Statistique {\n    - __hp : int\n    - __attaque : int\n    - __defense : int\n    - __spe_atk : int\n    - __spe_def : int\n    - __vitesse : int\n   }\n \n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  AbstractPokemon --* Statistique\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n\n\n\n\n\nVous devriez arriver Ã  une arborescence proche de celle-ci :\nğŸ“¦pokemon_unite_lite\n â”£ ğŸ“‚business_object\n â”ƒ â”£ ğŸ“‚pokemon\n â”ƒ â”ƒ â”£ ğŸ“œabstract_pokemon.py\n â”ƒ â”ƒ â”£ ğŸ“œattacker.py\n â”ƒ â”ƒ â”£ ğŸ“œdefender.py\n â”ƒ â”ƒ â”— ğŸ“œall_rounder.py\n â”ƒ â”— ğŸ“œ statistique.py\n â”— ğŸ“‚service\n   â”— ğŸ“œbattle_service.py\nPour faire une classe abstraite, utilisez le package abc.\nVoici, pour vous inspirer, un exemple de ce qui est attendu :\n# Fichier abstract_personnage.py\nfrom abc import ABC, abstractmethod\n\nclass AbstractPersonnage(ABC):\n    def __init__(self, phrase_attaque:str, phrase_defense:str) -&gt; None:\n        self._phrase_attaque = phrase_attaque\n        self._phrase_defense = phrase_defense\n       \n    @abstractmethod # dÃ©corateur qui dÃ©finit une mÃ©thode comme abstraite\n    def degat_attaque(self) -&gt; int:\n     pass\n\n# Fichier magicien.py\nfrom abstract_personnage import AbstractPersonnage\nclass Magicien(AbstractPersonnage):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Lance une boule de feu\",\"Utilise une barriÃ¨re magique\" )\n       \n    def degat_attaque(self) -&gt; int:\n        # code pour calculer les dÃ©gÃ¢ts\n        return 10\n\n\n\n\n\nQuestion 3 : Testez la mÃ©thode get_pokemon_attack_coef() pour les classes AttackerPokemon et AllRounderPokemon.\nPour lancer tous les tests du projet, exÃ©cutez dans le terminal : python -m unittest\n\n\nPour cela vous allez utiliser le package unittest de python.\nCe package permet de rÃ©aliser des tests unitaires dans des classes sÃ©parÃ©es. Lâ€™avantage par rapport Ã  doctest, câ€™est que les tests ne â€œpolluentâ€ pas vos classes, et quâ€™il est possible de patcher certains comportements des classes.\nUn exemple de test est donnÃ© dans la classe testDefenderPokemon. Pour rappel, un test se dÃ©compose en 3 parties :\n\nGIVEN : crÃ©ation des objets nÃ©cessaires Ã  la rÃ©alisation du test\nWHEN : appel de la mÃ©thode Ã  tester\nTHEN : vÃ©rification du rÃ©sultat\n\nLes classes de test seront organisÃ©es de la maniÃ¨re suivante, en reproduisant lâ€™architecture de votre application :\nğŸ“¦pokemon_unite_lite\n â”£ ğŸ“‚business_object\n â”ƒ â”£ ğŸ“‚pokemon\n â”ƒ â”ƒ â”£ ğŸ“œabstract_pokemon.py\n â”ƒ â”ƒ â”£ ğŸ“œattacker.py\n â”ƒ â”ƒ â”£ ğŸ“œdefender.py\n â”ƒ â”ƒ â”— ğŸ“œall_rounder.py\n â”ƒ â”— ğŸ“œ statistique.py\n â”£ ğŸ“‚service\n â”ƒ â”— ğŸ“œbattle_service.py\n â”— ğŸ“‚test\n  â”— ğŸ“‚test_business_object\n      â”— ğŸ“‚test_pokemon\n        â”£ ğŸ“œtest_abstract_pokemon.py\n        â”£ ğŸ“œtest_attacker_pokemon.py\n        â”£ ğŸ“œtest_defender_pokemon.py\n        â”— ğŸ“œtest_all_rounder_pokemon.py\n\nğŸ’¡ ProblÃ¨mes dâ€™imports\n\nVÃ©rifiez que le dossier parent dans lâ€™explorer de VSCode (Ã  gauche) est : ENSAI-2A-complement-info-TP\n\nSi câ€™est TP1 ou TP ou autre chose ce nâ€™est pas bon !\nSinon refaites : File &gt; open Folder\nCliquez une fois sur ENSAI-2A-complement-info-TP\nCliquez sur le bouton SÃ©lectionner un dossier\nSi Ã§a vous le demande, vous pouvez enregistrer vos modifications\n\nPrÃ©fÃ©rez utiliser des chemins complets dâ€™import plutÃ´t que des chemins relatifs\n\nla racine des chemins est paramÃ©trÃ©e au niveau du dossier src\ndonc cela donne par exemple : *from business_object.pokemon.abstract_pokemon import AbstractPokemon\n\ncar le dossier business_object est bien dans le dossier src\n\n\nCrÃ©ez des fichiers __init__.py (vide)\n\ndans TOUS les dossiers que vous crÃ©ez\ncâ€™est un peu pÃ©nible mais Ã§a peut dÃ©bloquer la situation\n\n\n\n\n\nQuestion 4 : Pouvez-vous tester la mÃ©thode level_up() directement sur un AbstractPokemon ? Avez vous une idÃ©e comment faire ? (ne pas coder cette question)\n\n\n\n\n\n\n\nMaintenant que nos PokÃ©mons sont faits, nous allons y ajouter les attaques.\nNotre systÃ¨me va devoir respecter certaines contraintes :\n\nPlusieurs types dâ€™attaques vont coexister, chacune avec un mode de calcul de dÃ©gÃ¢ts diffÃ©rent :\n\nDes attaques Ã  dÃ©gÃ¢ts variables sÃ©parÃ©es en 2 types :\n\nattaques â€œphysiquesâ€ qui utilisent lâ€™attaque et la dÃ©fense des PokÃ©mons\nattaques â€œspÃ©cialesâ€ qui utilisent lâ€™attaque spÃ© et la dÃ©fense spÃ© des PokÃ©mons\n\nDes attaques Ã  dÃ©gÃ¢ts fixes qui font un nombre fixe de dÃ©gÃ¢ts.\n\nUn pokÃ©mon peut avoir plusieurs attaques et le type de lâ€™attaque doit Ãªtre transparent pour le pokÃ©mon.\n\n\n\n\nNous allons commencer par les attaques Ã  dÃ©gÃ¢ts fixes. Comme il y aura un autre type dâ€™attaques, toutes les attaques hÃ©riterons de la classe abstraite AbstractAttack dÃ©jÃ  crÃ©Ã©e. Cette classe possÃ¨de la mÃ©thode abstraite compute_damage() qui devra Ãªtre implÃ©mentÃ©e dans les classes filles.\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n\n\n\n\n\n\n\nQuestion 5 ImplÃ©mentez la classe FixedDamageAttack, ainsi que sa mÃ©thode compute_damage() qui retournera simplement la puissance (power) de lâ€™attaque.\nCrÃ©ez des tests pour vÃ©rifier que tout fonctionne correctement.\n\n\n\n\n\n\nNous allons ensuite coder les attaques Ã  dÃ©gÃ¢ts variables. Elles utilisent la formule suivante :\nDamage = \\big ( \\frac{(\\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\\big) *random* other\\_multipliers\navec :\n\n\\(Att\\)â€‹ : Ã©gal soit Ã  lâ€™attaque ou lâ€™attaque spÃ© du Pokemon attaquant\n\\(Def\\)â€‹â€‹ : Ã©gal soit Ã  la dÃ©fense ou dÃ©fense spÃ© du Pokemon dÃ©fenseur\n\\(Power\\)â€‹ : la valeur de puissance de lâ€™attaque\n\\(random\\)â€‹â€‹ :une valeur comprise dans lâ€™intervalle [0.85; 1]\n\\(other\\_ multipliers\\) : les autres multiplicateurs possibles, comme le coefficient dâ€™attaque des pokÃ©mons.\n\nLa seule diffÃ©rence entre attaque physique et spÃ©ciale vient des coefficients \\(Att\\) et \\(Def\\), le reste de la formule des dÃ©gÃ¢ts est identique. Nous allons donc utiliser le patron de conception template method, dont voici la modÃ©lisation UML dans notre cas :\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    +compute_damage(APkm,APkm)  int\n  }\n \n  class PhysicalFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n   AbstractAttack &lt;|-- AbstractFormulaAttack\n   AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n   AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n\n\n\n\n\nLa classe AbstractFormulaAttack va contenir :\n\nla mÃ©thode compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon). Cette mÃ©thode va contenir la formule de calcul des dÃ©gÃ¢ts, mais en appelant les mÃ©thodes get_attaque_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon) pour savoir quelle statistique utiliser\nles mÃ©thodes abstraites get_attack_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon). Ces mÃ©thodes devront Ãªtre implÃ©mentÃ©es dans les classes filles pour dÃ©terminer quelles statistiques utiliser.\n\n\n\nQuestion 6 : ImplÃ©mentez les 3 nouvelles classes et crÃ©ez des tests pour vÃ©rifier que tout fonctionne correctement\n\n\n\n\n\n\n\nNous allons maintenant rattacher les bouts pour crÃ©er notre architecture finale :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    # _attack_list : List~AbstractAttack~\n    +get_pokemon_attack_coef()$  float\n    +level_up() None\n  }\n \n  class Statistique {\n    - hp : int\n    - attaque : int\n    - defense : int\n    - spe_atk : int\n    - spe_def : int\n    - vitesse : int\n  }\n   \n  class BattleService {\n    + resolve_battle(APkm, APkm) : Battle\n    + get_order(APkm, APkm)\n    + choose_attack(APkm) : AAttack\n  }  \n  \n  class Battle{\n    - first_monstie : APkm\n    - second_monstie : APkm\n    - winner : APkm\n    - rounds : List&lt;Round&gt;\n  }\n\n  class Round{\n    attacker: APkm\n    defender: APkm\n    dealt_damage: int\n    attack_description: str\n  }\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  Statistique *-- AbstractPokemon\n\n  Battle .. BattleService\n  Battle .. Round\n \n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$ int\n  }\n\n  class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n  }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    + compute_damage(APkm,APkm ) int\n  }\n \n  class PhysicalFormulaAttack{\n   -get_attack_stat(APkm)$  float\n   -get_defense_stat(APkm)$  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  AbstractAttack &lt;|-- FixedDamageAttack\n  AbstractAttack &lt;|-- AbstractFormulaAttack\n  AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n  AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n  BattleService &gt;.. AbstractAttack  : use\n  AbstractPokemon o--&gt;\"0..*\" AbstractAttack\n\n\n\n\n\n\n\n\nQuestion 7 : ImplÃ©mentez le diagramme de classe ci-dessus et testez votre code en Ã©crivant de nouveaux tests unitaires.\n\n\nCette architecture permet de dÃ©corrÃ©ler les attaques des pokÃ©mons et de spÃ©cifier le comportement des attaques au fur et Ã  mesure des hÃ©ritages. Les avantages sont :\n\nPour la classe AbstractPokemon, toutes les attaques sont des AbstractAttack. Tant quâ€™elles exposent la mÃ©thode compute_damage notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types dâ€™attaques sans problÃ¨me.\nUn PokÃ©mon peut avoir des attaques de tous les types\nNous pouvons ajouter un systÃ¨me dâ€™Ã©tat comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe AbstractAttack et les classes qui en hÃ©ritent. Cela sera potentiellement long, mais ne demande pas de toucher Ã  la partie â€œPokÃ©monâ€ de notre architecture.\nUne personne pourrait se concentrer sur la crÃ©ation des PokÃ©mons alors quâ€™une autre pourrait se concentrer sur celles des attaques sans difficultÃ©. Les deux parties du code sont relativement indÃ©pendantes, la seule zone de couplage sont les classes AbstractPokemon et AbstractAttack, qui servent avant tout Ã  dÃ©finir ce qui doit Ãªtre fait par les classes filles et ce qui est accessible Ã  lâ€™extÃ©rieur.\n\nLe fait dâ€™externaliser le comportement des attaques dans des classes spÃ©cifiques puis de les lier aux PokÃ©mons via une relation dâ€™agrÃ©gation assez souple qui permet de changer dynamiquement les attaques dâ€™un PokÃ©mon est le patron de conception strategy."
  },
  {
    "objectID": "docs/tp/tp1.html#avant-de-commencer",
    "href": "docs/tp/tp1.html#avant-de-commencer",
    "title": "TP1",
    "section": "",
    "text": "Ce TP mÃªle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais prÃ©fÃ©rez toujours les explications orales."
  },
  {
    "objectID": "docs/tp/tp1.html#introduction-et-mise-en-place",
    "href": "docs/tp/tp1.html#introduction-et-mise-en-place",
    "title": "TP1",
    "section": "",
    "text": "Vous allez crÃ©er les objets mÃ©tier pour un jeu PokÃ©mon.\nUn objet mÃ©tier reprÃ©sente dans votre code quelque chose de concret, qui modÃ¨lise la rÃ©alitÃ©.\n\nObjet mÃ©tier (business object) : reprÃ©sentation informatique dâ€™un objet â€œrÃ©elâ€ que notre programme va manipuler pour rÃ©pondre Ã  un besoin. Dans le cas de notre application cela sera des PokÃ©mons, des attaques ou des objets.\nDans une application de e-commerce par exemple, les articles et comptes sont des objets mÃ©tier. Ils permettent de sÃ©parer les donnÃ©es de lâ€™application et les traitements. Cela conduit Ã  avoir des objets contenant essentiellement des attributs et trÃ¨s peu de mÃ©thodes autre que des getter et setter.\n\nCe TP sera rÃ©alisÃ© avec lâ€™IDE (Integred Development Environment) Visual Studio Code.\n\n\n\nOuvrez Git Bash\nCrÃ©ez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, puis collez lÃ  dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_\n\nClonez le dÃ©pÃ´t\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAller dans /p/Cours2A/UE3_Complements_informatique/TP/TP1/ (ou dans le dossier oÃ¹ se situe le dÃ©pÃ´t que vous venez de cloner)\ncliquer sur ENSAI-2A-complement-info-TP, puis sur le bouton SÃ©lectionner un dossier\nâš ï¸ câ€™est trÃ¨s important de suivre trÃ¨s prÃ©cisÃ©ment ces consignes, sinon vous risquez dâ€™avoir des soucis dâ€™import !\n\n\n\nLisez le fichier README.md et suivez les instructions. Puis lancez le programme main.py pour vous assurer que tout fonctionne correctement.\n\nOuvrez un terminal dans VSCode (CTRL + Ã¹)\n\ncâ€™est le mÃªme terminal Git Bash que vous avez ouvert au dÃ©but\nmais câ€™est plus pratique dâ€™avoir tout au mÃªme endroit\n\nlistez les branches git branch -a\n\nVous avez la possibilitÃ© de consulter la correction en changeant de branche si et seulement si vous Ãªtes bloquÃ© trop longtemps.\nVoici quelques commandes git utiles :\n# Avant de changer de branches, crÃ©ez un point de sauvegarde de votre travail\ngit add .\ngit commit -am \"&lt;message&gt;\"\n\n# changer de branche\ngit checkout &lt;nouvelle_branche&gt;      # dans le terminal, la branche courante est indiquÃ©Ã©e entre ()\ngit checkout -                       # pour retourner Ã  la branche prÃ©cÃ©dente\n\n\n\n\nNotre jeu sâ€™inspirera de PokÃ©mon Unite (aucune connaissance du jeu, ni de PokÃ©mon nâ€™est nÃ©cessaire).\nPour rÃ©sumer en quelques mots, voici les objets que nous allons manipuler :\n\nPokemon : qui ont diverses caractÃ©ristiques et statistiques\n\nhp : health points\nattack, defense, speedâ€¦ : qui serviront dÃ©terminer la force de ses attaques\nun type : Attacker, Defender, All Rounder, Speedster, Supporter\n\nStatistic : pour Ã©viter de surcharger la classe Pokemon, de nombreuses stats sont stockÃ©es dans un objet de la classe Statistic\nAttack : diffÃ©rents types dâ€™attaques dont disposeront les PokÃ©mons (partie 3)\nBattleService : servira Ã  faire sâ€™affronter 2 PokÃ©mons pour dÃ©terminer lâ€™issue du combat (partie 4)"
  },
  {
    "objectID": "docs/tp/tp1.html#modÃ©lisation-et-implÃ©mentation",
    "href": "docs/tp/tp1.html#modÃ©lisation-et-implÃ©mentation",
    "title": "TP1",
    "section": "",
    "text": "Dans un premier temps, nous allons coder uniquement les Pokemons (la classe Statistic est dÃ©jÃ  codÃ©e). En fonction de son type, son coefficient dâ€™attaque dÃ©pendra de diverses statistiques.\n\n\n\n\n\nclassDiagram\n class Pokemon {\n - __type : String\n - __current_stat : Statistique\n + get_pokemon_attack_coef() float\n }\n \n class Statistic {\n - __hp : int\n - __attaque : int\n - __defense : int\n - __spe_atk : int\n - __spe_def : int\n - __vitesse : int\n }\n Pokemon --&gt; Statistic : possÃ¨de\n\n\n\n\n\nAvant dâ€™Ã©crire du code, nous allons rÃ©flÃ©chir Ã  la meilleure conception possible pour rÃ©aliser nos PokÃ©mons. Notre conception essaiera au maximum de respecter la rÃ¨gle suivante : faible couplage, forte cohÃ©sion.\nEn dâ€™autre termes nous allons essayer de faire :\n\ndes classes les plus disjointes possible (faible couplage) pour quâ€™une modification dans une classe ne nous demande pas de modifier les autres\ntout en essayant dâ€™avoir les tÃ¢ches rÃ©alisÃ©es par une seule classe les plus liÃ©es possible (forte cohÃ©sion).\n\n\n\nOuvrez le code, et observez la classe Pokemon. Nous nous interessons Ã  la mÃ©thode get_pokemon_attack_coef() qui va servir Ã  dÃ©terminer la puissance de lâ€™attaque en fonction du type de PokÃ©mon.\n\n\nQuestion 1 : Expliquez pourquoi une implÃ©mentation Ã  base de if/elif/else pour les types est une mauvaise idÃ©e ? Imaginez sâ€™il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.\n\n\n\n\n\n\nAu lieu dâ€™externaliser les comportements de nos PokÃ©mons, nous allons mettre tous leurs comportements spÃ©cifiques dans des classes filles dâ€™une super classe Pokemon. Ceci est rendu possible grÃ¢ce Ã  deux propriÃ©tÃ©s des objets en POO :\n\nhÃ©ritage : il est possible de spÃ©cialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux\npolymorphisme : deux fonctions peuvent avoir le mÃªme nom mais avoir des comportements diffÃ©rents\n\nEn plus, comme chacun de nos PokÃ©mons va forcement Ãªtre dâ€™un type, aucun ne sera simplement de la classe Pokemon, cela nous permet de rendre cette classe abstraite. En dÃ©finissant clairement notre classe abstraite nous allons avoir :\n\nUn plan pour toutes les classes qui en hÃ©ritent. Cela Ã  pour avantages de :\n\nDonner des informations sur la structuration du code\n\nPermettre de gÃ©nÃ©rer automatiquement les mÃ©thodes Ã  dÃ©finir\nLimiter les bug. Si on oublie une mÃ©thode, le code plante au dÃ©marrage, ce qui Ã©vite des comportements non prÃ©vus difficile Ã  dÃ©tecter\n\nUne interface unique pour tous les types de PokÃ©mons. Quelque soit le type du PokÃ©mon, il sera considÃ©rÃ© comme un AbstractPokemon partout dans le code.\n\n\n\n\nQuestion 2 :\n\ntransformez la classe Pokemon en classe abstraite AbstractPokemon\n\nrenommez Ã©galement le fichier en abstract_pokemon.py\n\ntransformez la mÃ©thode get_pokemon_attack_coef() en mÃ©thode abstraite\ncrÃ©ez les classes Attacker, Defender et AllRounder qui hÃ©ritent de AbstractPokemon\ndans ces 3 classes, implÃ©mentez la mÃ©thode get_pokemon_attack_coef()\n\n\n\nPour vous aider, voici le diagramme de classe :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    +get_pokemon_attack_coef() :  float\n  }\n  \n  class BattleService {\n    +resolve_battle() Battle\n  } \n \n  class Statistique {\n    - __hp : int\n    - __attaque : int\n    - __defense : int\n    - __spe_atk : int\n    - __spe_def : int\n    - __vitesse : int\n   }\n \n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  AbstractPokemon --* Statistique\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n\n\n\n\n\nVous devriez arriver Ã  une arborescence proche de celle-ci :\nğŸ“¦pokemon_unite_lite\n â”£ ğŸ“‚business_object\n â”ƒ â”£ ğŸ“‚pokemon\n â”ƒ â”ƒ â”£ ğŸ“œabstract_pokemon.py\n â”ƒ â”ƒ â”£ ğŸ“œattacker.py\n â”ƒ â”ƒ â”£ ğŸ“œdefender.py\n â”ƒ â”ƒ â”— ğŸ“œall_rounder.py\n â”ƒ â”— ğŸ“œ statistique.py\n â”— ğŸ“‚service\n   â”— ğŸ“œbattle_service.py\nPour faire une classe abstraite, utilisez le package abc.\nVoici, pour vous inspirer, un exemple de ce qui est attendu :\n# Fichier abstract_personnage.py\nfrom abc import ABC, abstractmethod\n\nclass AbstractPersonnage(ABC):\n    def __init__(self, phrase_attaque:str, phrase_defense:str) -&gt; None:\n        self._phrase_attaque = phrase_attaque\n        self._phrase_defense = phrase_defense\n       \n    @abstractmethod # dÃ©corateur qui dÃ©finit une mÃ©thode comme abstraite\n    def degat_attaque(self) -&gt; int:\n     pass\n\n# Fichier magicien.py\nfrom abstract_personnage import AbstractPersonnage\nclass Magicien(AbstractPersonnage):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Lance une boule de feu\",\"Utilise une barriÃ¨re magique\" )\n       \n    def degat_attaque(self) -&gt; int:\n        # code pour calculer les dÃ©gÃ¢ts\n        return 10\n\n\n\n\n\nQuestion 3 : Testez la mÃ©thode get_pokemon_attack_coef() pour les classes AttackerPokemon et AllRounderPokemon.\nPour lancer tous les tests du projet, exÃ©cutez dans le terminal : python -m unittest\n\n\nPour cela vous allez utiliser le package unittest de python.\nCe package permet de rÃ©aliser des tests unitaires dans des classes sÃ©parÃ©es. Lâ€™avantage par rapport Ã  doctest, câ€™est que les tests ne â€œpolluentâ€ pas vos classes, et quâ€™il est possible de patcher certains comportements des classes.\nUn exemple de test est donnÃ© dans la classe testDefenderPokemon. Pour rappel, un test se dÃ©compose en 3 parties :\n\nGIVEN : crÃ©ation des objets nÃ©cessaires Ã  la rÃ©alisation du test\nWHEN : appel de la mÃ©thode Ã  tester\nTHEN : vÃ©rification du rÃ©sultat\n\nLes classes de test seront organisÃ©es de la maniÃ¨re suivante, en reproduisant lâ€™architecture de votre application :\nğŸ“¦pokemon_unite_lite\n â”£ ğŸ“‚business_object\n â”ƒ â”£ ğŸ“‚pokemon\n â”ƒ â”ƒ â”£ ğŸ“œabstract_pokemon.py\n â”ƒ â”ƒ â”£ ğŸ“œattacker.py\n â”ƒ â”ƒ â”£ ğŸ“œdefender.py\n â”ƒ â”ƒ â”— ğŸ“œall_rounder.py\n â”ƒ â”— ğŸ“œ statistique.py\n â”£ ğŸ“‚service\n â”ƒ â”— ğŸ“œbattle_service.py\n â”— ğŸ“‚test\n  â”— ğŸ“‚test_business_object\n      â”— ğŸ“‚test_pokemon\n        â”£ ğŸ“œtest_abstract_pokemon.py\n        â”£ ğŸ“œtest_attacker_pokemon.py\n        â”£ ğŸ“œtest_defender_pokemon.py\n        â”— ğŸ“œtest_all_rounder_pokemon.py\n\nğŸ’¡ ProblÃ¨mes dâ€™imports\n\nVÃ©rifiez que le dossier parent dans lâ€™explorer de VSCode (Ã  gauche) est : ENSAI-2A-complement-info-TP\n\nSi câ€™est TP1 ou TP ou autre chose ce nâ€™est pas bon !\nSinon refaites : File &gt; open Folder\nCliquez une fois sur ENSAI-2A-complement-info-TP\nCliquez sur le bouton SÃ©lectionner un dossier\nSi Ã§a vous le demande, vous pouvez enregistrer vos modifications\n\nPrÃ©fÃ©rez utiliser des chemins complets dâ€™import plutÃ´t que des chemins relatifs\n\nla racine des chemins est paramÃ©trÃ©e au niveau du dossier src\ndonc cela donne par exemple : *from business_object.pokemon.abstract_pokemon import AbstractPokemon\n\ncar le dossier business_object est bien dans le dossier src\n\n\nCrÃ©ez des fichiers __init__.py (vide)\n\ndans TOUS les dossiers que vous crÃ©ez\ncâ€™est un peu pÃ©nible mais Ã§a peut dÃ©bloquer la situation\n\n\n\n\n\nQuestion 4 : Pouvez-vous tester la mÃ©thode level_up() directement sur un AbstractPokemon ? Avez vous une idÃ©e comment faire ? (ne pas coder cette question)"
  },
  {
    "objectID": "docs/tp/tp1.html#lagrÃ©gation-lautre-faÃ§on-dajouter-de-la-souplesse-dans-le-code",
    "href": "docs/tp/tp1.html#lagrÃ©gation-lautre-faÃ§on-dajouter-de-la-souplesse-dans-le-code",
    "title": "TP1",
    "section": "",
    "text": "Maintenant que nos PokÃ©mons sont faits, nous allons y ajouter les attaques.\nNotre systÃ¨me va devoir respecter certaines contraintes :\n\nPlusieurs types dâ€™attaques vont coexister, chacune avec un mode de calcul de dÃ©gÃ¢ts diffÃ©rent :\n\nDes attaques Ã  dÃ©gÃ¢ts variables sÃ©parÃ©es en 2 types :\n\nattaques â€œphysiquesâ€ qui utilisent lâ€™attaque et la dÃ©fense des PokÃ©mons\nattaques â€œspÃ©cialesâ€ qui utilisent lâ€™attaque spÃ© et la dÃ©fense spÃ© des PokÃ©mons\n\nDes attaques Ã  dÃ©gÃ¢ts fixes qui font un nombre fixe de dÃ©gÃ¢ts.\n\nUn pokÃ©mon peut avoir plusieurs attaques et le type de lâ€™attaque doit Ãªtre transparent pour le pokÃ©mon.\n\n\n\n\nNous allons commencer par les attaques Ã  dÃ©gÃ¢ts fixes. Comme il y aura un autre type dâ€™attaques, toutes les attaques hÃ©riterons de la classe abstraite AbstractAttack dÃ©jÃ  crÃ©Ã©e. Cette classe possÃ¨de la mÃ©thode abstraite compute_damage() qui devra Ãªtre implÃ©mentÃ©e dans les classes filles.\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n\n\n\n\n\n\n\nQuestion 5 ImplÃ©mentez la classe FixedDamageAttack, ainsi que sa mÃ©thode compute_damage() qui retournera simplement la puissance (power) de lâ€™attaque.\nCrÃ©ez des tests pour vÃ©rifier que tout fonctionne correctement.\n\n\n\n\n\n\nNous allons ensuite coder les attaques Ã  dÃ©gÃ¢ts variables. Elles utilisent la formule suivante :\nDamage = \\big ( \\frac{(\\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\\big) *random* other\\_multipliers\navec :\n\n\\(Att\\)â€‹ : Ã©gal soit Ã  lâ€™attaque ou lâ€™attaque spÃ© du Pokemon attaquant\n\\(Def\\)â€‹â€‹ : Ã©gal soit Ã  la dÃ©fense ou dÃ©fense spÃ© du Pokemon dÃ©fenseur\n\\(Power\\)â€‹ : la valeur de puissance de lâ€™attaque\n\\(random\\)â€‹â€‹ :une valeur comprise dans lâ€™intervalle [0.85; 1]\n\\(other\\_ multipliers\\) : les autres multiplicateurs possibles, comme le coefficient dâ€™attaque des pokÃ©mons.\n\nLa seule diffÃ©rence entre attaque physique et spÃ©ciale vient des coefficients \\(Att\\) et \\(Def\\), le reste de la formule des dÃ©gÃ¢ts est identique. Nous allons donc utiliser le patron de conception template method, dont voici la modÃ©lisation UML dans notre cas :\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    +compute_damage(APkm,APkm)  int\n  }\n \n  class PhysicalFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n   AbstractAttack &lt;|-- AbstractFormulaAttack\n   AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n   AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n\n\n\n\n\nLa classe AbstractFormulaAttack va contenir :\n\nla mÃ©thode compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon). Cette mÃ©thode va contenir la formule de calcul des dÃ©gÃ¢ts, mais en appelant les mÃ©thodes get_attaque_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon) pour savoir quelle statistique utiliser\nles mÃ©thodes abstraites get_attack_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon). Ces mÃ©thodes devront Ãªtre implÃ©mentÃ©es dans les classes filles pour dÃ©terminer quelles statistiques utiliser.\n\n\n\nQuestion 6 : ImplÃ©mentez les 3 nouvelles classes et crÃ©ez des tests pour vÃ©rifier que tout fonctionne correctement"
  },
  {
    "objectID": "docs/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "href": "docs/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "title": "TP1",
    "section": "",
    "text": "Nous allons maintenant rattacher les bouts pour crÃ©er notre architecture finale :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    # _attack_list : List~AbstractAttack~\n    +get_pokemon_attack_coef()$  float\n    +level_up() None\n  }\n \n  class Statistique {\n    - hp : int\n    - attaque : int\n    - defense : int\n    - spe_atk : int\n    - spe_def : int\n    - vitesse : int\n  }\n   \n  class BattleService {\n    + resolve_battle(APkm, APkm) : Battle\n    + get_order(APkm, APkm)\n    + choose_attack(APkm) : AAttack\n  }  \n  \n  class Battle{\n    - first_monstie : APkm\n    - second_monstie : APkm\n    - winner : APkm\n    - rounds : List&lt;Round&gt;\n  }\n\n  class Round{\n    attacker: APkm\n    defender: APkm\n    dealt_damage: int\n    attack_description: str\n  }\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  Statistique *-- AbstractPokemon\n\n  Battle .. BattleService\n  Battle .. Round\n \n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$ int\n  }\n\n  class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n  }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    + compute_damage(APkm,APkm ) int\n  }\n \n  class PhysicalFormulaAttack{\n   -get_attack_stat(APkm)$  float\n   -get_defense_stat(APkm)$  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  AbstractAttack &lt;|-- FixedDamageAttack\n  AbstractAttack &lt;|-- AbstractFormulaAttack\n  AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n  AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n  BattleService &gt;.. AbstractAttack  : use\n  AbstractPokemon o--&gt;\"0..*\" AbstractAttack\n\n\n\n\n\n\n\n\nQuestion 7 : ImplÃ©mentez le diagramme de classe ci-dessus et testez votre code en Ã©crivant de nouveaux tests unitaires.\n\n\nCette architecture permet de dÃ©corrÃ©ler les attaques des pokÃ©mons et de spÃ©cifier le comportement des attaques au fur et Ã  mesure des hÃ©ritages. Les avantages sont :\n\nPour la classe AbstractPokemon, toutes les attaques sont des AbstractAttack. Tant quâ€™elles exposent la mÃ©thode compute_damage notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types dâ€™attaques sans problÃ¨me.\nUn PokÃ©mon peut avoir des attaques de tous les types\nNous pouvons ajouter un systÃ¨me dâ€™Ã©tat comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe AbstractAttack et les classes qui en hÃ©ritent. Cela sera potentiellement long, mais ne demande pas de toucher Ã  la partie â€œPokÃ©monâ€ de notre architecture.\nUne personne pourrait se concentrer sur la crÃ©ation des PokÃ©mons alors quâ€™une autre pourrait se concentrer sur celles des attaques sans difficultÃ©. Les deux parties du code sont relativement indÃ©pendantes, la seule zone de couplage sont les classes AbstractPokemon et AbstractAttack, qui servent avant tout Ã  dÃ©finir ce qui doit Ãªtre fait par les classes filles et ce qui est accessible Ã  lâ€™extÃ©rieur.\n\nLe fait dâ€™externaliser le comportement des attaques dans des classes spÃ©cifiques puis de les lier aux PokÃ©mons via une relation dâ€™agrÃ©gation assez souple qui permet de changer dynamiquement les attaques dâ€™un PokÃ©mon est le patron de conception strategy."
  }
]