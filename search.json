[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cours de compléments d’informatique",
    "section": "",
    "text": "🚧\n\nObjectifs\nVous apporter les connaissances pour :\n\nmener à bien votre projet informatique\ndévelopper votre culture informatique\nvous permettre de comprendre les outils de traitements de la donnée\n\nDifférentes notions vont être vues pendant ce cours. Certaines en CM, d’autres en TP. Des ressources complémentaires vous sont proposées si vous souhaitez parfaire vos connaissances.\n\n\nOrganisation\n\nCM : 4x1h30\nTP : 4x3h\n\n\n\nCours\n\nCours n°1\nCours n°2\n\n\n\nTP\n\nTP n°1"
  },
  {
    "objectID": "docs/cours/cm2.html#comment-stocker-les-données",
    "href": "docs/cours/cm2.html#comment-stocker-les-données",
    "title": "CM2",
    "section": "1.1 Comment stocker les données",
    "text": "1.1 Comment stocker les données\ndans calc"
  },
  {
    "objectID": "docs/cours/cm2.html#les-bddr",
    "href": "docs/cours/cm2.html#les-bddr",
    "title": "CM2",
    "section": "1.2 les bddr",
    "text": "1.2 les bddr\nBddr"
  },
  {
    "objectID": "docs/cours/cm1.html#comment-stocker-les-données",
    "href": "docs/cours/cm1.html#comment-stocker-les-données",
    "title": "CM1",
    "section": "1.1 Comment stocker les données",
    "text": "1.1 Comment stocker les données\ndans calc"
  },
  {
    "objectID": "docs/cours/cm1.html#les-bddr",
    "href": "docs/cours/cm1.html#les-bddr",
    "title": "CM1",
    "section": "1.2 les bddr",
    "text": "1.2 les bddr\nBddr"
  },
  {
    "objectID": "docs/tp/tp1.html",
    "href": "docs/tp/tp1.html",
    "title": "TP1",
    "section": "",
    "text": "Ce TP mêle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais préférez toujours les explications orales.\n\n\n\n\nVous allez créer les objets métier pour un jeu Pokémon.\nUn objet métier représente dans votre code quelque chose de concret, qui modèlise la réalité.\n\nObjet métier (business object) : représentation informatique d’un objet “réel” que notre programme va manipuler pour répondre à un besoin. Dans le cas de notre application cela sera des Pokémons, des attaques ou des objets.\nDans une application de e-commerce par exemple, les articles et comptes sont des objets métier. Ils permettent de séparer les données de l’application et les traitements. Cela conduit à avoir des objets contenant essentiellement des attributs et très peu de méthodes autre que des getter et setter.\n\nCe TP sera réalisé avec l’IDE (Integred Development Environment) Visual Studio Code.\n\n\n\nOuvrez Git Bash\nCréez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, puis collez là dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_\n\nClonez le dépôt\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAller dans /p/Cours2A/UE3_Complements_informatique/TP/TP1/ (ou dans le dossier où se situe le dépôt que vous venez de cloner)\ncliquer sur ENSAI-2A-complement-info-TP, puis sur le bouton Sélectionner un dossier\n⚠️ c’est très important de suivre très précisément ces consignes, sinon vous risquez d’avoir des soucis d’import !\n\n\n\nLisez le fichier README.md et suivez les instructions. Puis lancez le programme main.py pour vous assurer que tout fonctionne correctement.\n\nOuvrez un terminal dans VSCode (CTRL + ù)\n\nc’est le même terminal Git Bash que vous avez ouvert au début\nmais c’est plus pratique d’avoir tout au même endroit\n\nlistez les branches git branch -a\n\nVous avez la possibilité de consulter la correction en changeant de branche si et seulement si vous êtes bloqué trop longtemps.\nVoici quelques commandes git utiles :\n# Avant de changer de branches, créez un point de sauvegarde de votre travail\ngit add .\ngit commit -am \"&lt;message&gt;\"\n\n# changer de branche\ngit checkout &lt;nouvelle_branche&gt;      # dans le terminal, la branche courante est indiquéée entre ()\ngit checkout -                       # pour retourner à la branche précédente\n\n\n\n\nNotre jeu s’inspirera de Pokémon Unite (aucune connaissance du jeu, ni de Pokémon n’est nécessaire).\nPour résumer en quelques mots, voici les objets que nous allons manipuler :\n\nPokemon : qui ont diverses caractéristiques et statistiques\n\nhp : health points\nattack, defense, speed… : qui serviront déterminer la force de ses attaques\nun type : Attacker, Defender, All Rounder, Speedster, Supporter\n\nStatistic : pour éviter de surcharger la classe Pokemon, de nombreuses stats sont stockées dans un objet de la classe Statistic\nAttack : différents types d’attaques dont disposeront les Pokémons (partie 3)\nBattleService : servira à faire s’affronter 2 Pokémons pour déterminer l’issue du combat (partie 4)\n\n\n\n\n\n\n\nDans un premier temps, nous allons coder uniquement les Pokemons (la classe Statistic est déjà codée). En fonction de son type, son coefficient d’attaque dépendra de diverses statistiques.\n\n\n\n\n\nclassDiagram\n class Pokemon {\n - __type : String\n - __current_stat : Statistique\n + get_pokemon_attack_coef() float\n }\n \n class Statistic {\n - __hp : int\n - __attaque : int\n - __defense : int\n - __spe_atk : int\n - __spe_def : int\n - __vitesse : int\n }\n Pokemon --&gt; Statistic : possède\n\n\n\n\n\nAvant d’écrire du code, nous allons réfléchir à la meilleure conception possible pour réaliser nos Pokémons. Notre conception essaiera au maximum de respecter la règle suivante : faible couplage, forte cohésion.\nEn d’autre termes nous allons essayer de faire :\n\ndes classes les plus disjointes possible (faible couplage) pour qu’une modification dans une classe ne nous demande pas de modifier les autres\ntout en essayant d’avoir les tâches réalisées par une seule classe les plus liées possible (forte cohésion).\n\n\n\nOuvrez le code, et observez la classe Pokemon. Nous nous interessons à la méthode get_pokemon_attack_coef() qui va servir à déterminer la puissance de l’attaque en fonction du type de Pokémon.\n\n\nQuestion 1 : Expliquez pourquoi une implémentation à base de if/elif/else pour les types est une mauvaise idée ? Imaginez s’il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.\n\n\n\n\n\n\nAu lieu d’externaliser les comportements de nos Pokémons, nous allons mettre tous leurs comportements spécifiques dans des classes filles d’une super classe Pokemon. Ceci est rendu possible grâce à deux propriétés des objets en POO :\n\nhéritage : il est possible de spécialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux\npolymorphisme : deux fonctions peuvent avoir le même nom mais avoir des comportements différents\n\nEn plus, comme chacun de nos Pokémons va forcement être d’un type, aucun ne sera simplement de la classe Pokemon, cela nous permet de rendre cette classe abstraite. En définissant clairement notre classe abstraite nous allons avoir :\n\nUn plan pour toutes les classes qui en héritent. Cela à pour avantages de :\n\nDonner des informations sur la structuration du code\n\nPermettre de générer automatiquement les méthodes à définir\nLimiter les bug. Si on oublie une méthode, le code plante au démarrage, ce qui évite des comportements non prévus difficile à détecter\n\nUne interface unique pour tous les types de Pokémons. Quelque soit le type du Pokémon, il sera considéré comme un AbstractPokemon partout dans le code.\n\n\n\n\nQuestion 2 :\n\ntransformez la classe Pokemon en classe abstraite AbstractPokemon\n\nrenommez également le fichier en abstract_pokemon.py\n\ntransformez la méthode get_pokemon_attack_coef() en méthode abstraite\ncréez les classes Attacker, Defender et AllRounder qui héritent de AbstractPokemon\ndans ces 3 classes, implémentez la méthode get_pokemon_attack_coef()\n\n\n\nPour vous aider, voici le diagramme de classe :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    +get_pokemon_attack_coef() :  float\n  }\n  \n  class BattleService {\n    +resolve_battle() Battle\n  } \n \n  class Statistique {\n    - __hp : int\n    - __attaque : int\n    - __defense : int\n    - __spe_atk : int\n    - __spe_def : int\n    - __vitesse : int\n   }\n \n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  AbstractPokemon --* Statistique\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n\n\n\n\n\nVous devriez arriver à une arborescence proche de celle-ci :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┗ 📂service\n   ┗ 📜battle_service.py\nPour faire une classe abstraite, utilisez le package abc.\nVoici, pour vous inspirer, un exemple de ce qui est attendu :\n# Fichier abstract_personnage.py\nfrom abc import ABC, abstractmethod\n\nclass AbstractPersonnage(ABC):\n    def __init__(self, phrase_attaque:str, phrase_defense:str) -&gt; None:\n        self._phrase_attaque = phrase_attaque\n        self._phrase_defense = phrase_defense\n       \n    @abstractmethod # décorateur qui définit une méthode comme abstraite\n    def degat_attaque(self) -&gt; int:\n     pass\n\n# Fichier magicien.py\nfrom abstract_personnage import AbstractPersonnage\nclass Magicien(AbstractPersonnage):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Lance une boule de feu\",\"Utilise une barrière magique\" )\n       \n    def degat_attaque(self) -&gt; int:\n        # code pour calculer les dégâts\n        return 10\n\n\n\n\n\nQuestion 3 : Testez la méthode get_pokemon_attack_coef() pour les classes AttackerPokemon et AllRounderPokemon.\nPour lancer tous les tests du projet, exécutez dans le terminal : python -m unittest\n\n\nPour cela vous allez utiliser le package unittest de python.\nCe package permet de réaliser des tests unitaires dans des classes séparées. L’avantage par rapport à doctest, c’est que les tests ne “polluent” pas vos classes, et qu’il est possible de patcher certains comportements des classes.\nUn exemple de test est donné dans la classe testDefenderPokemon. Pour rappel, un test se décompose en 3 parties :\n\nGIVEN : création des objets nécessaires à la réalisation du test\nWHEN : appel de la méthode à tester\nTHEN : vérification du résultat\n\nLes classes de test seront organisées de la manière suivante, en reproduisant l’architecture de votre application :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┣ 📂service\n ┃ ┗ 📜battle_service.py\n ┗ 📂test\n  ┗ 📂test_business_object\n      ┗ 📂test_pokemon\n        ┣ 📜test_abstract_pokemon.py\n        ┣ 📜test_attacker_pokemon.py\n        ┣ 📜test_defender_pokemon.py\n        ┗ 📜test_all_rounder_pokemon.py\n\n💡 Problèmes d’imports\n\nVérifiez que le dossier parent dans l’explorer de VSCode (à gauche) est : ENSAI-2A-complement-info-TP\n\nSi c’est TP1 ou TP ou autre chose ce n’est pas bon !\nSinon refaites : File &gt; open Folder\nCliquez une fois sur ENSAI-2A-complement-info-TP\nCliquez sur le bouton Sélectionner un dossier\nSi ça vous le demande, vous pouvez enregistrer vos modifications\n\nPréférez utiliser des chemins complets d’import plutôt que des chemins relatifs\n\nla racine des chemins est paramétrée au niveau du dossier src\ndonc cela donne par exemple : *from business_object.pokemon.abstract_pokemon import AbstractPokemon\n\ncar le dossier business_object est bien dans le dossier src\n\n\nCréez des fichiers __init__.py (vide)\n\ndans TOUS les dossiers que vous créez\nc’est un peu pénible mais ça peut débloquer la situation\n\n\n\n\n\nQuestion 4 : Pouvez-vous tester la méthode level_up() directement sur un AbstractPokemon ? Avez vous une idée comment faire ? (ne pas coder cette question)\n\n\n\n\n\n\n\nMaintenant que nos Pokémons sont faits, nous allons y ajouter les attaques.\nNotre système va devoir respecter certaines contraintes :\n\nPlusieurs types d’attaques vont coexister, chacune avec un mode de calcul de dégâts différent :\n\nDes attaques à dégâts variables séparées en 2 types :\n\nattaques “physiques” qui utilisent l’attaque et la défense des Pokémons\nattaques “spéciales” qui utilisent l’attaque spé et la défense spé des Pokémons\n\nDes attaques à dégâts fixes qui font un nombre fixe de dégâts.\n\nUn pokémon peut avoir plusieurs attaques et le type de l’attaque doit être transparent pour le pokémon.\n\n\n\n\nNous allons commencer par les attaques à dégâts fixes. Comme il y aura un autre type d’attaques, toutes les attaques hériterons de la classe abstraite AbstractAttack déjà créée. Cette classe possède la méthode abstraite compute_damage() qui devra être implémentée dans les classes filles.\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n\n\n\n\n\n\n\nQuestion 5 Implémentez la classe FixedDamageAttack, ainsi que sa méthode compute_damage() qui retournera simplement la puissance (power) de l’attaque.\nCréez des tests pour vérifier que tout fonctionne correctement.\n\n\n\n\n\n\nNous allons ensuite coder les attaques à dégâts variables. Elles utilisent la formule suivante :\nDamage = \\big ( \\frac{(\\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\\big) *random* other\\_multipliers\navec :\n\n\\(Att\\)​ : égal soit à l’attaque ou l’attaque spé du Pokemon attaquant\n\\(Def\\)​​ : égal soit à la défense ou défense spé du Pokemon défenseur\n\\(Power\\)​ : la valeur de puissance de l’attaque\n\\(random\\)​​ :une valeur comprise dans l’intervalle [0.85; 1]\n\\(other\\_ multipliers\\) : les autres multiplicateurs possibles, comme le coefficient d’attaque des pokémons.\n\nLa seule différence entre attaque physique et spéciale vient des coefficients \\(Att\\) et \\(Def\\), le reste de la formule des dégâts est identique. Nous allons donc utiliser le patron de conception template method, dont voici la modélisation UML dans notre cas :\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    +compute_damage(APkm,APkm)  int\n  }\n \n  class PhysicalFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n   AbstractAttack &lt;|-- AbstractFormulaAttack\n   AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n   AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n\n\n\n\n\nLa classe AbstractFormulaAttack va contenir :\n\nla méthode compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon). Cette méthode va contenir la formule de calcul des dégâts, mais en appelant les méthodes get_attaque_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon) pour savoir quelle statistique utiliser\nles méthodes abstraites get_attack_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon). Ces méthodes devront être implémentées dans les classes filles pour déterminer quelles statistiques utiliser.\n\n\n\nQuestion 6 : Implémentez les 3 nouvelles classes et créez des tests pour vérifier que tout fonctionne correctement\n\n\n\n\n\n\n\nNous allons maintenant rattacher les bouts pour créer notre architecture finale :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    # _attack_list : List~AbstractAttack~\n    +get_pokemon_attack_coef()$  float\n    +level_up() None\n  }\n \n  class Statistique {\n    - hp : int\n    - attaque : int\n    - defense : int\n    - spe_atk : int\n    - spe_def : int\n    - vitesse : int\n  }\n   \n  class BattleService {\n    + resolve_battle(APkm, APkm) : Battle\n    + get_order(APkm, APkm)\n    + choose_attack(APkm) : AAttack\n  }  \n  \n  class Battle{\n    - first_monstie : APkm\n    - second_monstie : APkm\n    - winner : APkm\n    - rounds : List&lt;Round&gt;\n  }\n\n  class Round{\n    attacker: APkm\n    defender: APkm\n    dealt_damage: int\n    attack_description: str\n  }\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  Statistique *-- AbstractPokemon\n\n  Battle .. BattleService\n  Battle .. Round\n \n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$ int\n  }\n\n  class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n  }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    + compute_damage(APkm,APkm ) int\n  }\n \n  class PhysicalFormulaAttack{\n   -get_attack_stat(APkm)$  float\n   -get_defense_stat(APkm)$  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  AbstractAttack &lt;|-- FixedDamageAttack\n  AbstractAttack &lt;|-- AbstractFormulaAttack\n  AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n  AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n  BattleService &gt;.. AbstractAttack  : use\n  AbstractPokemon o--&gt;\"0..*\" AbstractAttack\n\n\n\n\n\n\n\n\nQuestion 7 : Implémentez le diagramme de classe ci-dessus et testez votre code en écrivant de nouveaux tests unitaires.\n\n\nCette architecture permet de décorréler les attaques des pokémons et de spécifier le comportement des attaques au fur et à mesure des héritages. Les avantages sont :\n\nPour la classe AbstractPokemon, toutes les attaques sont des AbstractAttack. Tant qu’elles exposent la méthode compute_damage notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types d’attaques sans problème.\nUn Pokémon peut avoir des attaques de tous les types\nNous pouvons ajouter un système d’état comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe AbstractAttack et les classes qui en héritent. Cela sera potentiellement long, mais ne demande pas de toucher à la partie “Pokémon” de notre architecture.\nUne personne pourrait se concentrer sur la création des Pokémons alors qu’une autre pourrait se concentrer sur celles des attaques sans difficulté. Les deux parties du code sont relativement indépendantes, la seule zone de couplage sont les classes AbstractPokemon et AbstractAttack, qui servent avant tout à définir ce qui doit être fait par les classes filles et ce qui est accessible à l’extérieur.\n\nLe fait d’externaliser le comportement des attaques dans des classes spécifiques puis de les lier aux Pokémons via une relation d’agrégation assez souple qui permet de changer dynamiquement les attaques d’un Pokémon est le patron de conception strategy."
  },
  {
    "objectID": "docs/tp/tp1.html#avant-de-commencer",
    "href": "docs/tp/tp1.html#avant-de-commencer",
    "title": "TP1",
    "section": "",
    "text": "Ce TP mêle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais préférez toujours les explications orales."
  },
  {
    "objectID": "docs/tp/tp1.html#introduction-et-mise-en-place",
    "href": "docs/tp/tp1.html#introduction-et-mise-en-place",
    "title": "TP1",
    "section": "",
    "text": "Vous allez créer les objets métier pour un jeu Pokémon.\nUn objet métier représente dans votre code quelque chose de concret, qui modèlise la réalité.\n\nObjet métier (business object) : représentation informatique d’un objet “réel” que notre programme va manipuler pour répondre à un besoin. Dans le cas de notre application cela sera des Pokémons, des attaques ou des objets.\nDans une application de e-commerce par exemple, les articles et comptes sont des objets métier. Ils permettent de séparer les données de l’application et les traitements. Cela conduit à avoir des objets contenant essentiellement des attributs et très peu de méthodes autre que des getter et setter.\n\nCe TP sera réalisé avec l’IDE (Integred Development Environment) Visual Studio Code.\n\n\n\nOuvrez Git Bash\nCréez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, puis collez là dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_\n\nClonez le dépôt\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAller dans /p/Cours2A/UE3_Complements_informatique/TP/TP1/ (ou dans le dossier où se situe le dépôt que vous venez de cloner)\ncliquer sur ENSAI-2A-complement-info-TP, puis sur le bouton Sélectionner un dossier\n⚠️ c’est très important de suivre très précisément ces consignes, sinon vous risquez d’avoir des soucis d’import !\n\n\n\nLisez le fichier README.md et suivez les instructions. Puis lancez le programme main.py pour vous assurer que tout fonctionne correctement.\n\nOuvrez un terminal dans VSCode (CTRL + ù)\n\nc’est le même terminal Git Bash que vous avez ouvert au début\nmais c’est plus pratique d’avoir tout au même endroit\n\nlistez les branches git branch -a\n\nVous avez la possibilité de consulter la correction en changeant de branche si et seulement si vous êtes bloqué trop longtemps.\nVoici quelques commandes git utiles :\n# Avant de changer de branches, créez un point de sauvegarde de votre travail\ngit add .\ngit commit -am \"&lt;message&gt;\"\n\n# changer de branche\ngit checkout &lt;nouvelle_branche&gt;      # dans le terminal, la branche courante est indiquéée entre ()\ngit checkout -                       # pour retourner à la branche précédente\n\n\n\n\nNotre jeu s’inspirera de Pokémon Unite (aucune connaissance du jeu, ni de Pokémon n’est nécessaire).\nPour résumer en quelques mots, voici les objets que nous allons manipuler :\n\nPokemon : qui ont diverses caractéristiques et statistiques\n\nhp : health points\nattack, defense, speed… : qui serviront déterminer la force de ses attaques\nun type : Attacker, Defender, All Rounder, Speedster, Supporter\n\nStatistic : pour éviter de surcharger la classe Pokemon, de nombreuses stats sont stockées dans un objet de la classe Statistic\nAttack : différents types d’attaques dont disposeront les Pokémons (partie 3)\nBattleService : servira à faire s’affronter 2 Pokémons pour déterminer l’issue du combat (partie 4)"
  },
  {
    "objectID": "docs/tp/tp1.html#modélisation-et-implémentation",
    "href": "docs/tp/tp1.html#modélisation-et-implémentation",
    "title": "TP1",
    "section": "",
    "text": "Dans un premier temps, nous allons coder uniquement les Pokemons (la classe Statistic est déjà codée). En fonction de son type, son coefficient d’attaque dépendra de diverses statistiques.\n\n\n\n\n\nclassDiagram\n class Pokemon {\n - __type : String\n - __current_stat : Statistique\n + get_pokemon_attack_coef() float\n }\n \n class Statistic {\n - __hp : int\n - __attaque : int\n - __defense : int\n - __spe_atk : int\n - __spe_def : int\n - __vitesse : int\n }\n Pokemon --&gt; Statistic : possède\n\n\n\n\n\nAvant d’écrire du code, nous allons réfléchir à la meilleure conception possible pour réaliser nos Pokémons. Notre conception essaiera au maximum de respecter la règle suivante : faible couplage, forte cohésion.\nEn d’autre termes nous allons essayer de faire :\n\ndes classes les plus disjointes possible (faible couplage) pour qu’une modification dans une classe ne nous demande pas de modifier les autres\ntout en essayant d’avoir les tâches réalisées par une seule classe les plus liées possible (forte cohésion).\n\n\n\nOuvrez le code, et observez la classe Pokemon. Nous nous interessons à la méthode get_pokemon_attack_coef() qui va servir à déterminer la puissance de l’attaque en fonction du type de Pokémon.\n\n\nQuestion 1 : Expliquez pourquoi une implémentation à base de if/elif/else pour les types est une mauvaise idée ? Imaginez s’il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.\n\n\n\n\n\n\nAu lieu d’externaliser les comportements de nos Pokémons, nous allons mettre tous leurs comportements spécifiques dans des classes filles d’une super classe Pokemon. Ceci est rendu possible grâce à deux propriétés des objets en POO :\n\nhéritage : il est possible de spécialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux\npolymorphisme : deux fonctions peuvent avoir le même nom mais avoir des comportements différents\n\nEn plus, comme chacun de nos Pokémons va forcement être d’un type, aucun ne sera simplement de la classe Pokemon, cela nous permet de rendre cette classe abstraite. En définissant clairement notre classe abstraite nous allons avoir :\n\nUn plan pour toutes les classes qui en héritent. Cela à pour avantages de :\n\nDonner des informations sur la structuration du code\n\nPermettre de générer automatiquement les méthodes à définir\nLimiter les bug. Si on oublie une méthode, le code plante au démarrage, ce qui évite des comportements non prévus difficile à détecter\n\nUne interface unique pour tous les types de Pokémons. Quelque soit le type du Pokémon, il sera considéré comme un AbstractPokemon partout dans le code.\n\n\n\n\nQuestion 2 :\n\ntransformez la classe Pokemon en classe abstraite AbstractPokemon\n\nrenommez également le fichier en abstract_pokemon.py\n\ntransformez la méthode get_pokemon_attack_coef() en méthode abstraite\ncréez les classes Attacker, Defender et AllRounder qui héritent de AbstractPokemon\ndans ces 3 classes, implémentez la méthode get_pokemon_attack_coef()\n\n\n\nPour vous aider, voici le diagramme de classe :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    +get_pokemon_attack_coef() :  float\n  }\n  \n  class BattleService {\n    +resolve_battle() Battle\n  } \n \n  class Statistique {\n    - __hp : int\n    - __attaque : int\n    - __defense : int\n    - __spe_atk : int\n    - __spe_def : int\n    - __vitesse : int\n   }\n \n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  AbstractPokemon --* Statistique\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n\n\n\n\n\nVous devriez arriver à une arborescence proche de celle-ci :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┗ 📂service\n   ┗ 📜battle_service.py\nPour faire une classe abstraite, utilisez le package abc.\nVoici, pour vous inspirer, un exemple de ce qui est attendu :\n# Fichier abstract_personnage.py\nfrom abc import ABC, abstractmethod\n\nclass AbstractPersonnage(ABC):\n    def __init__(self, phrase_attaque:str, phrase_defense:str) -&gt; None:\n        self._phrase_attaque = phrase_attaque\n        self._phrase_defense = phrase_defense\n       \n    @abstractmethod # décorateur qui définit une méthode comme abstraite\n    def degat_attaque(self) -&gt; int:\n     pass\n\n# Fichier magicien.py\nfrom abstract_personnage import AbstractPersonnage\nclass Magicien(AbstractPersonnage):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Lance une boule de feu\",\"Utilise une barrière magique\" )\n       \n    def degat_attaque(self) -&gt; int:\n        # code pour calculer les dégâts\n        return 10\n\n\n\n\n\nQuestion 3 : Testez la méthode get_pokemon_attack_coef() pour les classes AttackerPokemon et AllRounderPokemon.\nPour lancer tous les tests du projet, exécutez dans le terminal : python -m unittest\n\n\nPour cela vous allez utiliser le package unittest de python.\nCe package permet de réaliser des tests unitaires dans des classes séparées. L’avantage par rapport à doctest, c’est que les tests ne “polluent” pas vos classes, et qu’il est possible de patcher certains comportements des classes.\nUn exemple de test est donné dans la classe testDefenderPokemon. Pour rappel, un test se décompose en 3 parties :\n\nGIVEN : création des objets nécessaires à la réalisation du test\nWHEN : appel de la méthode à tester\nTHEN : vérification du résultat\n\nLes classes de test seront organisées de la manière suivante, en reproduisant l’architecture de votre application :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┣ 📂service\n ┃ ┗ 📜battle_service.py\n ┗ 📂test\n  ┗ 📂test_business_object\n      ┗ 📂test_pokemon\n        ┣ 📜test_abstract_pokemon.py\n        ┣ 📜test_attacker_pokemon.py\n        ┣ 📜test_defender_pokemon.py\n        ┗ 📜test_all_rounder_pokemon.py\n\n💡 Problèmes d’imports\n\nVérifiez que le dossier parent dans l’explorer de VSCode (à gauche) est : ENSAI-2A-complement-info-TP\n\nSi c’est TP1 ou TP ou autre chose ce n’est pas bon !\nSinon refaites : File &gt; open Folder\nCliquez une fois sur ENSAI-2A-complement-info-TP\nCliquez sur le bouton Sélectionner un dossier\nSi ça vous le demande, vous pouvez enregistrer vos modifications\n\nPréférez utiliser des chemins complets d’import plutôt que des chemins relatifs\n\nla racine des chemins est paramétrée au niveau du dossier src\ndonc cela donne par exemple : *from business_object.pokemon.abstract_pokemon import AbstractPokemon\n\ncar le dossier business_object est bien dans le dossier src\n\n\nCréez des fichiers __init__.py (vide)\n\ndans TOUS les dossiers que vous créez\nc’est un peu pénible mais ça peut débloquer la situation\n\n\n\n\n\nQuestion 4 : Pouvez-vous tester la méthode level_up() directement sur un AbstractPokemon ? Avez vous une idée comment faire ? (ne pas coder cette question)"
  },
  {
    "objectID": "docs/tp/tp1.html#lagrégation-lautre-façon-dajouter-de-la-souplesse-dans-le-code",
    "href": "docs/tp/tp1.html#lagrégation-lautre-façon-dajouter-de-la-souplesse-dans-le-code",
    "title": "TP1",
    "section": "",
    "text": "Maintenant que nos Pokémons sont faits, nous allons y ajouter les attaques.\nNotre système va devoir respecter certaines contraintes :\n\nPlusieurs types d’attaques vont coexister, chacune avec un mode de calcul de dégâts différent :\n\nDes attaques à dégâts variables séparées en 2 types :\n\nattaques “physiques” qui utilisent l’attaque et la défense des Pokémons\nattaques “spéciales” qui utilisent l’attaque spé et la défense spé des Pokémons\n\nDes attaques à dégâts fixes qui font un nombre fixe de dégâts.\n\nUn pokémon peut avoir plusieurs attaques et le type de l’attaque doit être transparent pour le pokémon.\n\n\n\n\nNous allons commencer par les attaques à dégâts fixes. Comme il y aura un autre type d’attaques, toutes les attaques hériterons de la classe abstraite AbstractAttack déjà créée. Cette classe possède la méthode abstraite compute_damage() qui devra être implémentée dans les classes filles.\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n\n\n\n\n\n\n\nQuestion 5 Implémentez la classe FixedDamageAttack, ainsi que sa méthode compute_damage() qui retournera simplement la puissance (power) de l’attaque.\nCréez des tests pour vérifier que tout fonctionne correctement.\n\n\n\n\n\n\nNous allons ensuite coder les attaques à dégâts variables. Elles utilisent la formule suivante :\nDamage = \\big ( \\frac{(\\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\\big) *random* other\\_multipliers\navec :\n\n\\(Att\\)​ : égal soit à l’attaque ou l’attaque spé du Pokemon attaquant\n\\(Def\\)​​ : égal soit à la défense ou défense spé du Pokemon défenseur\n\\(Power\\)​ : la valeur de puissance de l’attaque\n\\(random\\)​​ :une valeur comprise dans l’intervalle [0.85; 1]\n\\(other\\_ multipliers\\) : les autres multiplicateurs possibles, comme le coefficient d’attaque des pokémons.\n\nLa seule différence entre attaque physique et spéciale vient des coefficients \\(Att\\) et \\(Def\\), le reste de la formule des dégâts est identique. Nous allons donc utiliser le patron de conception template method, dont voici la modélisation UML dans notre cas :\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    +compute_damage(APkm,APkm)  int\n  }\n \n  class PhysicalFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n   AbstractAttack &lt;|-- AbstractFormulaAttack\n   AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n   AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n\n\n\n\n\nLa classe AbstractFormulaAttack va contenir :\n\nla méthode compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon). Cette méthode va contenir la formule de calcul des dégâts, mais en appelant les méthodes get_attaque_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon) pour savoir quelle statistique utiliser\nles méthodes abstraites get_attack_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon). Ces méthodes devront être implémentées dans les classes filles pour déterminer quelles statistiques utiliser.\n\n\n\nQuestion 6 : Implémentez les 3 nouvelles classes et créez des tests pour vérifier que tout fonctionne correctement"
  },
  {
    "objectID": "docs/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "href": "docs/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "title": "TP1",
    "section": "",
    "text": "Nous allons maintenant rattacher les bouts pour créer notre architecture finale :\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    # _attack_list : List~AbstractAttack~\n    +get_pokemon_attack_coef()$  float\n    +level_up() None\n  }\n \n  class Statistique {\n    - hp : int\n    - attaque : int\n    - defense : int\n    - spe_atk : int\n    - spe_def : int\n    - vitesse : int\n  }\n   \n  class BattleService {\n    + resolve_battle(APkm, APkm) : Battle\n    + get_order(APkm, APkm)\n    + choose_attack(APkm) : AAttack\n  }  \n  \n  class Battle{\n    - first_monstie : APkm\n    - second_monstie : APkm\n    - winner : APkm\n    - rounds : List&lt;Round&gt;\n  }\n\n  class Round{\n    attacker: APkm\n    defender: APkm\n    dealt_damage: int\n    attack_description: str\n  }\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  Statistique *-- AbstractPokemon\n\n  Battle .. BattleService\n  Battle .. Round\n \n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$ int\n  }\n\n  class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n  }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    + compute_damage(APkm,APkm ) int\n  }\n \n  class PhysicalFormulaAttack{\n   -get_attack_stat(APkm)$  float\n   -get_defense_stat(APkm)$  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  AbstractAttack &lt;|-- FixedDamageAttack\n  AbstractAttack &lt;|-- AbstractFormulaAttack\n  AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n  AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n  BattleService &gt;.. AbstractAttack  : use\n  AbstractPokemon o--&gt;\"0..*\" AbstractAttack\n\n\n\n\n\n\n\n\nQuestion 7 : Implémentez le diagramme de classe ci-dessus et testez votre code en écrivant de nouveaux tests unitaires.\n\n\nCette architecture permet de décorréler les attaques des pokémons et de spécifier le comportement des attaques au fur et à mesure des héritages. Les avantages sont :\n\nPour la classe AbstractPokemon, toutes les attaques sont des AbstractAttack. Tant qu’elles exposent la méthode compute_damage notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types d’attaques sans problème.\nUn Pokémon peut avoir des attaques de tous les types\nNous pouvons ajouter un système d’état comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe AbstractAttack et les classes qui en héritent. Cela sera potentiellement long, mais ne demande pas de toucher à la partie “Pokémon” de notre architecture.\nUne personne pourrait se concentrer sur la création des Pokémons alors qu’une autre pourrait se concentrer sur celles des attaques sans difficulté. Les deux parties du code sont relativement indépendantes, la seule zone de couplage sont les classes AbstractPokemon et AbstractAttack, qui servent avant tout à définir ce qui doit être fait par les classes filles et ce qui est accessible à l’extérieur.\n\nLe fait d’externaliser le comportement des attaques dans des classes spécifiques puis de les lier aux Pokémons via une relation d’agrégation assez souple qui permet de changer dynamiquement les attaques d’un Pokémon est le patron de conception strategy."
  }
]